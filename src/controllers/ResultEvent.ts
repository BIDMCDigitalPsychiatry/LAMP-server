import { SQL, Encrypt, Decrypt, Download } from '../index'
import { 
	d, Schema, Property, Description, Retype, Route, Throws, 
	Path, BadRequest, NotFound, AuthorizationFailed, Auth,
	Enum, Ownership, Identifier, Parent, Body, Double, Int64, Timestamp
} from '../utils/OpenAPI'
import { IResult } from 'mssql'

import { Participant } from './Participant'
import { Study } from './Study'
import { Researcher } from './Researcher'
import { Activity } from './Activity'

export enum TemporalEventType {
	None = 'none',
	Correct = 'correct',
	Valid = 'valid',
}
Enum(TemporalEventType, d`
	The type of temporal event.
`)

@Schema()
@Description(d`
	A specific sub-detail of a \`ResultEvent\` that contains specific 
	interaction information that comprises the parent \`ResultEvent\`.
`)
export class TemporalEvent {

	@Property()
	@Description(d`
		The item that was interacted with; for example, in a Jewels game, the 
		corresponding alphabet, or in a survey, the question index.
	`)
	public item?: any

	@Property()
	@Description(d`
		The value of the item that was interacted with; in most games, 
		this field is \`null\`, but in a survey, this field is the question 
		choice index.
	`)
	public value?: any

	@Property()
	@Description(d`
		The type of interaction that for this detail; for example, in 
		a Jewels game, \`TemporalEventType.none\` if the tapped jewel was 
		incorrect, or \`TemporalEventType.correct\` if it was correct, or in 
		a survey, this field will be \`null\`.
	`)
	public type?: TemporalEventType

	@Property()
	@Description(d`
		The time difference from the previous detail or the 
		start of the parent result.
	`)
	public duration?: Int64

	@Property()
	@Description(d`
		The level of activity for this detail; for example, in 
		games with multiple levels, this field might be \`2\` or 
		\`4\`, but for surveys and other games this field will 
		be \`null\`.
	`)
	public level?: Int64
}

@Schema()
@Parent(Participant)
@Description(d`
	An event generated by the participant interacting with an \`Activity\`.
`)
export class ResultEvent {

	@Property()
	@Description(d`
		The self-referencing identifier to this object.
	`)
	public id?: Identifier

	@Property()
	@Description(d`
		External or out-of-line objects attached to this object.
	`)
	public attachments?: any

	@Property()
	@Description(d`
		The date and time when this event was recorded.
	`)
	public timestamp?: Timestamp

	@Property()
	@Description(d`
		The duration this event lasted before recording ended.
	`)
	public duration?: Int64

	@Property()
	@Description(d`
		The activity that produced this result event.
	`)
	public activity?: Identifier

	@Property()
	@Description(d`
		The summary information for the result event as determined by the 
		activity that created this result event.
	`)
	public static_data?: any

	@Property()
	@Description(d`
		The specific interaction details of the result event.
	`)
	public temporal_events?: TemporalEvent[]

	@Route.POST('/participant/{participant_id}/activity/{activity_id}/result_event') 
	@Description(d`
		Create a new ResultEvent for the given Participant.
	`)
	@Auth(Ownership.Self, 'participant_id')
	@Retype(Identifier, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async create(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string,

		@Path('activity_id')
		@Retype(Identifier, Activity)
		activity_id: string,

		@Body()
		result_event: ResultEvent,

	): Promise<Identifier> {
		return ResultEvent._insert(participant_id, activity_id, result_event)
	}

	@Route.PUT('/result_event/{result_event_id}') 
	@Description(d`
		Update a ResultEvent.
	`)
	@Auth(Ownership.Self, 'result_event_id')
	@Retype(Identifier, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async update(

		@Path('result_event_id')
		@Retype(Identifier, ResultEvent)
		result_event_id: string,

		@Body()
		result_event: ResultEvent,

	): Promise<Identifier> {
		return ResultEvent._update(result_event_id, result_event)
	}

	@Route.DELETE('/result_event/{result_event_id}') 
	@Description(d`
		Delete a ResultEvent.
	`)
	@Auth(Ownership.Self, 'result_event_id')
	@Retype(Identifier, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async delete(

		@Path('result_event_id')
		@Retype(Identifier, ResultEvent)
		result_event_id: string

	): Promise<Identifier> {
		return ResultEvent._delete(result_event_id)
	}

	@Route.GET('/result_event/{result_event_id}') 
	@Description(d`
		Get a single result event, by identifier.
	`)
	@Auth(Ownership.Self, 'result_event_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async view(

		@Path('result_event_id')
		@Retype(Identifier, ResultEvent)
		result_event_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(result_event_id)
	}

	@Route.GET('/participant/{participant_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by a 
		given participant, by identifier.
	`)
	@Auth(Ownership.Parent, 'participant_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_participant(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(participant_id)
	}

	@Route.GET('/study/{study_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by participants 
		participants of a single study, by study identifier.
	`)
	@Auth(Ownership.Parent, 'study_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_study(

		@Path('study_id')
		@Retype(Identifier, Study)
		study_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(study_id)
	}

	@Route.GET('/researcher/{researcher_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by participants 
		of any study conducted by a researcher, by researcher identifier.
	`)
	@Auth(Ownership.Parent, 'researcher_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_researcher(

		@Path('researcher_id')
		@Retype(Identifier, Researcher)
		researcher_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(researcher_id)
	}

	@Route.GET('/participant/{participant_id}/activity/{activity_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by a 
		given participant, by identifier.
	`)
	@Auth(Ownership.Parent, 'participant_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_participant_activity(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string,

		@Path('activity_id')
		@Retype(Identifier, Activity)
		activity_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(participant_id, activity_id)
	}

	@Route.GET('/study/{study_id}/activity/{activity_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by participants 
		participants of a single study, by study identifier.
	`)
	@Auth(Ownership.Parent, 'study_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_study_activity(

		@Path('study_id')
		@Retype(Identifier, Study)
		study_id: string,

		@Path('activity_id')
		@Retype(Identifier, Activity)
		activity_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(study_id, activity_id)
	}

	@Route.GET('/researcher/{researcher_id}/activity/{activity_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by participants 
		of any study conducted by a researcher, by researcher identifier.
	`)
	@Auth(Ownership.Parent, 'researcher_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_researcher_activity(

		@Path('researcher_id')
		@Retype(Identifier, Researcher)
		researcher_id: string,

		@Path('activity_id')
		@Retype(Identifier, Activity)
		activity_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(researcher_id, activity_id)
	}

	@Route.GET('/activity/{activity_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by participants 
		of any study conducted by a researcher, by researcher identifier.
	`)
	@Auth(Ownership.Parent, 'activity_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_activity(

		@Path('activity_id')
		@Retype(Identifier, Activity)
		activity_id: string

	): Promise<ResultEvent[]> {
		return ResultEvent._select(activity_id)
	}

	@Route.GET('/result_event') 
	@Description(d`
		Get the set of all result events.
	`)
	@Auth(Ownership.Root)
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all(

	): Promise<ResultEvent[]> {
		return ResultEvent._select()
	}

	/**
	 *
	 */
	public static _pack_id(components: {

		/**
		 * 
		 */
		ctest_id?: any

		/**
		 * 
		 */
		event_id?: number

	}): Identifier {
		return Identifier.pack([
			(<any>ResultEvent).name, 
			components.ctest_id || 0,
			components.event_id || 0,
		])
	}

	/**
	 *
	 */
	public static _unpack_id(id: Identifier): ({

		/**
		 * 
		 */
		ctest_id: any

		/**
		 * 
		 */
		event_id: number

	}) {
		let components = Identifier.unpack(id)
		if (components[0] !== (<any>ResultEvent).name)
			throw new Error('invalid identifier')
		let result = components.slice(1).map(parseInt)
		return {
			ctest_id: !isNaN(result[1]) ? result[1] : 0,
			event_id: !isNaN(result[0]) ? result[0] : 0,
		}
	}

	/**
	 *
	 */
	public static async _parent_id(id: Identifier, type: Function): Promise<Identifier | undefined> {
		let { event_id } = ResultEvent._unpack_id(id)
		switch (type) {
			default: throw new Error()
		}
	}

	/**
	 * Get a set of `ResultEvent`s matching the criteria parameters.
	 */
	private static async _select(

		/**
		 * 
		 */
		id?: Identifier,

		/**
		 * 
		 */
		activity_id?: Identifier // FIXME: UNUSED!

	): Promise<ResultEvent[]> {

		// Get the correctly scoped identifier to search within.
		let user_id: string | undefined
		let admin_id: number | undefined
		let result_id: number | undefined
		if (!!id && Identifier.unpack(id)[0] === (<any>Researcher).name)
			admin_id = Researcher._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id)[0] === (<any>Study).name)
			admin_id = Study._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id).length === 0 /* Participant */)
			user_id = Participant._unpack_id(id).study_id
		else if (!!id && Identifier.unpack(id)[0] === (<any>ResultEvent).name)
			result_id = ResultEvent._unpack_id(id).event_id
		else if(!!id) throw new Error()

		user_id = !!user_id ? Encrypt(user_id) : user_id
		let conds = [
			!!user_id ? `Users.StudyId = '${user_id}'` : null,
			!!admin_id ? `Users.AdminID = '${admin_id}'` : null
		].filter(x => !!x)
		let str = (conds.length > 0 ? ('WHERE ' + conds.join(' AND ')) : '')

		// Collect the set of legacy Activity tables and stitch the full query.
		let result = (await SQL!.request().query(`
			SELECT * FROM LAMP_Aux.dbo.ActivityIndex;
		`)).recordset.map(async (entry: any) => {

			// Perform the result lookup for every Activity table.
			let events = (await SQL!.request().query(`
				SELECT
	                [${entry.IndexColumnName}] AS id,
	                DATEDIFF_BIG(MS, '1970-01-01', [${entry.StartTimeColumnName}]) AS timestamp,
	                DATEDIFF_BIG(MS, [${entry.StartTimeColumnName}], [${entry.EndTimeColumnName}]) AS duration,
	                ${!entry.Slot1Name ?  '' :
	                    `[${entry.Slot1ColumnName}] AS [static_data.${entry.Slot1Name}],`}
	                ${!entry.Slot2Name ? '' :
	                    `[${entry.Slot2ColumnName}] AS [static_data.${entry.Slot2Name}],`}
	                ${!entry.Slot3Name ? '': 
	                    `[${entry.Slot3ColumnName}] AS [static_data.${entry.Slot3Name}],`}
	                ${!entry.Slot4Name ? '' :
	                    `[${entry.Slot4ColumnName}] AS [static_data.${entry.Slot4Name}],`}
	                ${!entry.Slot5Name ? '' : 
	                    `[${entry.Slot5ColumnName}] AS [static_data.${entry.Slot5Name}],`}
	                Users.AdminID AS aid
	            FROM [${entry.TableName}]
	            LEFT JOIN Users
	                ON [${entry.TableName}].UserID = Users.UserID
	            ${str};
			`)).recordsets

			if (events.length === 0)
				return []

			// If temporal events are recorded by the activity, look all of them up as well.
			let slices: any[] = []
			if (!!entry.TemporalTableName) {
				slices = (await SQL!.request().query(`
	                SELECT
	                    [${entry.TemporalTableName}].[${entry.IndexColumnName}] AS parent_id,
	                    ${!!entry.Temporal1ColumnName ? 
	                        `[${entry.TemporalTableName}].[${entry.Temporal1ColumnName}]` :
	                        '(NULL)'} AS item,
	                    ${!!entry.Temporal2ColumnName ?
	                        `[${entry.TemporalTableName}].[${entry.Temporal2ColumnName}]` :
	                        '(NULL)'} AS value,
	                    ${!!entry.Temporal3ColumnName ?
	                        `[${entry.TemporalTableName}].[${entry.Temporal3ColumnName}]` :
	                        '(NULL)'} AS type,
	                    ${!!entry.Temporal4ColumnName ?
	                        `CAST(CAST([${entry.TemporalTableName}].[${entry.Temporal4ColumnName}] AS float) * 1000 AS bigint)` :
	                        '(NULL)'} AS duration,
	                    ${!!entry.Temporal5ColumnName ?
	                        `[${entry.TemporalTableName}].[${entry.Temporal5ColumnName}]` :
	                        '(NULL)'} AS level
	                FROM [${entry.TemporalTableName}]
	                LEFT JOIN [${entry.TableName}]
	                    ON [${entry.TableName}].[${entry.IndexColumnName}] = [${entry.TemporalTableName}].[${entry.IndexColumnName}]
		            LEFT JOIN Users
		                ON [${entry.TableName}].UserID = Users.UserID
	                ${str};
				`)).recordset
			}

			// Map from SQL DB to the local ResultEvent type.
			return events.map((row: any) => {
				let result_event = new ResultEvent()

				// Map internal ID sub-components into the single mangled ID form.
				// FIXME: Currently it's not feasible to map SurveyID from SurveyName.
				result_event.id = ResultEvent._pack_id({ ctest_id: entry.ActivityIndexID, event_id: row.id })
				result_event.activity = entry.ActivityIndexID === 1 /* survey */ ? undefined : 
										Activity._pack_id({ activity_spec_id: entry.ActivityIndexID, admin_id: row.aid, survey_id: 0 })
				result_event.timestamp = parseInt(row.timestamp)
				result_event.duration = parseInt(row.duration)

				// Copy static data fields if declared.
				result_event.static_data = {}
				if (!!entry.Slot1ColumnName)
					result_event.static_data[entry.Slot1Name] = row[`static_data.${entry.Slot1Name}`]
				if (!!entry.Slot2ColumnName)
					result_event.static_data[entry.Slot2Name] = row[`static_data.${entry.Slot2Name}`]
				if (!!entry.Slot3ColumnName)
					result_event.static_data[entry.Slot3Name] = row[`static_data.${entry.Slot3Name}`]
				if (!!entry.Slot4ColumnName)
					result_event.static_data[entry.Slot4Name] = row[`static_data.${entry.Slot4Name}`]
				if (!!entry.Slot5ColumnName)
					result_event.static_data[entry.Slot5Name] = row[`static_data.${entry.Slot5Name}`]

				// Decrypt all static data properties if known to be encrypted.
				// TODO: Encryption of fields should also be found in the ActivityIndex table!
				if (!!result_event.static_data.survey_name)
					result_event.static_data.survey_name = Decrypt(result_event.static_data.survey_name) || result_event.static_data.survey_name
				if (!!result_event.static_data.drawn_fig_file_name) {
					let fname = 'https://psych.digital/LampWeb/Games/User3DFigures/' + (Decrypt(result_event.static_data.drawn_fig_file_name) || result_event.static_data.drawn_fig_file_name)
					result_event.static_data.drawn_fig_file_name = Download(fname)
				}
                if (!!result_event.static_data.scratch_file_name) {
                    let fname = 'https://psych.digital/LampWeb/Games/UserScratchImages/' + (Decrypt(result_event.static_data.scratch_file_name) || result_event.static_data.scratch_file_name)
                    result_event.static_data.scratch_file_name = Download(fname)
                }
				if (!!result_event.static_data.game_name)
					result_event.static_data.game_name = Decrypt(result_event.static_data.game_name) || result_event.static_data.game_name
				if (!!result_event.static_data.collected_stars)
					result_event.static_data.collected_stars = Decrypt(result_event.static_data.collected_stars) || result_event.static_data.collected_stars
				if (!!result_event.static_data.total_jewels_collected)
					result_event.static_data.total_jewels_collected = Decrypt(result_event.static_data.total_jewels_collected) || result_event.static_data.total_jewels_collected
				if (!!result_event.static_data.total_bonus_collected)
					result_event.static_data.total_bonus_collected = Decrypt(result_event.static_data.total_bonus_collected) || result_event.static_data.total_bonus_collected
				if (!!result_event.static_data.score)
					result_event.static_data.score = Decrypt(result_event.static_data.score) || result_event.static_data.score

				// Copy all temporal events for this result event by matching parent ID.
				result_event.temporal_events = !!slices ? [] : undefined
				if (!!slices) {
					result_event.temporal_events = slices
						.filter(slice_row => slice_row.parent_id === row.id)
						.map(slice_row => {
							let temporal_event = new TemporalEvent()
							temporal_event.item = slice_row.item
							temporal_event.value = slice_row.value
							temporal_event.type = slice_row.type
							temporal_event.duration = parseInt(slice_row.duration)
							temporal_event.level = slice_row.level

							// Special treatment for surveys with encrypted answers.
							if (entry.ActivityIndexID === '1' /* survey */) {
								temporal_event.item = Decrypt(temporal_event.item) || temporal_event.item
								temporal_event.value = Decrypt(temporal_event.value) || temporal_event.value
								temporal_event.type = (<TemporalEventType>(<string>temporal_event.type).toLowerCase())

								// Adjust the Likert scaled values to numbers.
								if (["Not at all", "12:00AM - 06:00AM", "0-3"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 0
								} else if (["Several Times", "06:00AM - 12:00PM", "3-6"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 1
								} else if (["More than Half the Time", "12:00PM - 06:00PM", "6-9"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 2
								} else if (["Nearly All the Time", "06:00PM - 12:00AM", ">9"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 3
								}
							}
							return temporal_event
						})
				}

				// Finally return the newly created event.
				return result_event
			})
		})

		return (<ResultEvent[]>[]).concat(...(await Promise.all(result)))
	}

	/**
	 * Add a new `ResultEvent` with new fields.
	 */
	private static async _insert(

		/**
		 * The `StudyId` column of the `Users` table in the LAMP v0.1 DB.
		 */
		participant_id: Identifier,

		/**
		 * The `ActivityID` column of the `ActivityIndex` table in the LAMP v0.1 DB.
		 */
		activity_id: Identifier,

		/**
		 * The new object to append.
		 */
		object: ResultEvent

	): Promise<Identifier> {

		let user_id = Participant._unpack_id(participant_id).study_id
		let { activity_spec_id, admin_id, survey_id } = Activity._unpack_id(activity_id)
		// FIXME: USE SURVEY ID!!!

		// Collect the set of legacy Activity tables and stitch the full query.
		let tableset = (await SQL!.request().query(`
			SELECT * FROM LAMP_Aux.dbo.ActivityIndex;
		`)).recordset
		let tablerow = tableset.filter((x: any) => x['ActivityIndexID'] === activity_spec_id)[0]

	    // First consume the timestamp + duration fields that are always present.
	    // TODO: convert time!
	    let columns: any = {}
	    columns[tablerow['StartTimeColumnName']] = object.static_data.timestamp
	    columns[tablerow['EndTimeColumnName']] = object.static_data.timestamp + object.static_data.duration

	    // We only support 5 static slots; check if they're used by the activity first.
	    for (let x of [1, 2, 3, 4, 5]) {
	    	if (!!tablerow[`Slot${x}Name`]) {
	    		columns[tablerow[`Slot${x}ColumnName`]] = object.static_data[tablerow[`Slot${x}Name`]]
	    	}
	    }
	    
	    // Convert the static array into SQL strings.
	    let static_keys = Object.keys(columns).join(', ')
	    let static_values = Object.values(columns).join(', ')

	    // Insert row, returning the generated primary key ID.
	    let result: any = (await SQL!.request().query(`
	    	INSERT INTO ${tablerow['TableName']} (
                ${static_keys}
            )
            OUTPUT INSERTED.${tablerow['IndexColumnName']} AS id
			VALUES (
		        ${static_values}
			);
	    `)).recordset

	    // Bail early if there was a failure to record the parent event row.
	    if (result.length === 0)
	    	throw new Error()
	    if (!!tablerow['TemporalTableName'])
	    	return result[0]

	    // Now the temporal fields are mapped for each sub-event.
	    let temporals = (object.temporal_events || []).map(event => [
	    	[tablerow['TemporalIndexColumnName'], result.id],
		    [tablerow['Temporal1ColumnName'], event.item],
		    [tablerow['Temporal2ColumnName'], event.value],
		    [tablerow['Temporal3ColumnName'], event.type],
		    [tablerow['Temporal4ColumnName'], event.duration],
		    [tablerow['Temporal5ColumnName'], event.level],
	    ].reduce((prev, curr) => {
	    	(<any>prev)[curr[0]] = curr[1]; return prev
	    }, {}))

	    // Convert the temporal arrays into SQL strings.
	    let temporal_keys = `(${Object.keys(temporals[0]).join(', ')})`
	    let temporal_values = temporals.map(x => `(${Object.values(x).join(', ')})`).join(', ')

	    // Insert sub-rows, without returning anything.
	    let result2 = await SQL!.request().query(`
	    	INSERT INTO ${tablerow['TemporalTableName']} ${temporal_keys}
			VALUES ${temporal_values};
	    `)

	    // Return the new parent row's ID.
	    return !!result2 ? result : null;
	}

	/**
	 * Update a `ResultEvent` with new fields.
	 */
	private static async _update(

		/**
		 * The `ActivityID` column of the `ActivityIndex` table in the LAMP v0.1 DB.
		 */
		event_id: Identifier,

		/**
		 * The replacement object or specific fields within.
		 */
		object?: ResultEvent

	): Promise<Identifier> {

		let c = ResultEvent._unpack_id(event_id)
		let activity_id = c.ctest_id
		let type_id = c.event_id

		// TODO: ResultEvent cannot be updated yet. Maybe never?
		throw new Error()
		return ''
	}

	/**
	 * Deletes a `ResultEvent` row.
	 */
	private static async _delete(

		/**
		 *
		 */
		event_id: Identifier

	): Promise<Identifier> {

		let c = ResultEvent._unpack_id(event_id)
		let activity_id = c.ctest_id
		let type_id = c.event_id

		// Collect the set of legacy Activity tables and stitch the full query.
		let tableset = (await SQL!.request().query(`
			SELECT * FROM LAMP_Aux.dbo.ActivityIndex;
		`)).recordset
		let tablerow = tableset.filter((x: any) => x['ActivityIndexID'] === activity_id)[0]

		// Set the deletion flag, without actually deleting the row. Return whether the operation was successful.
		// TODO: Deletion is not supported! CreatedOn is not correctly used here.

		return (await SQL!.request().query(`
			UPDATE ${tablerow['TableName']} SET CreatedOn = NULL WHERE ${tablerow['IndexColumnName']} = ${type_id};
		`)).recordset[0]
	}
}
