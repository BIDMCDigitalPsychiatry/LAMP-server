import { SQL, Encrypt, Decrypt, Download } from '../app'
import { 
	d, Schema, Property, Description, Retype, Route, Throws, Unimplemented,
	Path, BadRequest, NotFound, AuthorizationFailed, Auth, Query,
	Enum, Ownership, Identifier, Parent, Body, Double, Int64, Timestamp
} from '../utils/OpenAPI'
import { IResult } from 'mssql'

import { Type } from './Type'
import { Participant } from './Participant'
import { Study } from './Study'
import { Researcher } from './Researcher'
import { Activity } from './Activity'

@Schema()
@Description(d`
	A specific sub-detail of a \`ResultEvent\` that contains specific 
	interaction information that comprises the parent \`ResultEvent\`.
`)
export class TemporalEvent {

	@Property()
	@Description(d`
		The item that was interacted with; for example, in a Jewels game, the 
		corresponding alphabet, or in a survey, the question index.
	`)
	public item?: any

	@Property()
	@Description(d`
		The value of the item that was interacted with; in most games, 
		this field is \`null\`, but in a survey, this field is the question 
		choice index.
	`)
	public value?: any

	@Property()
	@Description(d`
		The type of interaction that for this detail; for example, in 
		a Jewels game, \`none\` if the tapped jewel was 
		incorrect, or \`correct\` if it was correct, or in 
		a survey, this field will be \`null\`.
	`)
	public type?: string

	@Property()
	@Description(d`
		The time difference from the previous detail or the 
		start of the parent result.
	`)
	public duration?: Int64

	@Property()
	@Description(d`
		The level of activity for this detail; for example, in 
		games with multiple levels, this field might be \`2\` or 
		\`4\`, but for surveys and other games this field will 
		be \`null\`.
	`)
	public level?: Int64
}

@Schema()
@Parent(Participant)
@Description(d`
	An event generated by the participant interacting with an \`Activity\`.
`)
export class ResultEvent {

	@Property()
	@Description(d`
		The date and time when this event was recorded.
	`)
	public timestamp?: Timestamp

	@Property()
	@Description(d`
		The duration this event lasted before recording ended.
	`)
	public duration?: Int64

	@Property()
	@Description(d`
		The activity that produced this result event.
	`)
	public activity?: Identifier

	@Property()
	@Description(d`
		The summary information for the result event as determined by the 
		activity that created this result event.
	`)
	public static_data?: any

	@Property()
	@Description(d`
		The specific interaction details of the result event.
	`)
	public temporal_events?: TemporalEvent[]

	@Route.POST('/participant/{participant_id}/result_event') 
	@Description(d`
		Create a new ResultEvent for the given Participant.
	`)
	@Auth(Ownership.Self | Ownership.Sibling | Ownership.Parent, 'participant_id')
	@Retype(Identifier, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async create(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string,

		@Body()
		result_event: ResultEvent,

	): Promise<{}> {
		return ResultEvent._insert(participant_id, result_event)
	}

	@Route.DELETE('/participant/{participant_id}/result_event') 
	@Description(d`
		Delete a ResultEvent.
	`)
	@Auth(Ownership.Self | Ownership.Sibling | Ownership.Parent, 'result_event_id')
	@Retype(Identifier, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async delete(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string,

		@Query('origin')
		origin?: string,

		@Query('from')
		from?: number,

		@Query('to')
		to?: number

	): Promise<{}> {
		return ResultEvent._delete(participant_id, origin, from, to)
	}

	@Route.GET('/participant/{participant_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by a 
		given participant, by identifier.
	`)
	@Auth(Ownership.Self | Ownership.Sibling | Ownership.Parent, 'participant_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_participant(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string,

		@Query('origin')
		origin?: string,

		@Query('from')
		from?: number,

		@Query('to')
		to?: number

	): Promise<ResultEvent[]> {
		return ResultEvent._select(participant_id, origin, from, to)
	}

	@Route.GET('/study/{study_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by participants 
		participants of a single study, by study identifier.
	`)
	@Auth(Ownership.Self | Ownership.Sibling | Ownership.Parent, 'study_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_study(

		@Path('study_id')
		@Retype(Identifier, Study)
		study_id: string,

		@Query('origin')
		origin?: string,

		@Query('from')
		from?: number,

		@Query('to')
		to?: number

	): Promise<ResultEvent[]> {
		return ResultEvent._select(study_id, origin, from, to)
	}

	@Route.GET('/researcher/{researcher_id}/result_event') 
	@Description(d`
		Get the set of all result events produced by participants 
		of any study conducted by a researcher, by researcher identifier.
	`)
	@Auth(Ownership.Self | Ownership.Sibling | Ownership.Parent, 'researcher_id')
	@Retype(Array, ResultEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_researcher(

		@Path('researcher_id')
		@Retype(Identifier, Researcher)
		researcher_id: string,

		@Query('origin')
		origin?: string,

		@Query('from')
		from?: number,

		@Query('to')
		to?: number

	): Promise<ResultEvent[]> {
		return ResultEvent._select(researcher_id, origin, from, to)
	}

	/**
	 * Get a set of `ResultEvent`s matching the criteria parameters.
	 */
	private static async _select(

		/**
		 * 
		 */
		id?: Identifier,

		/**
		 * 
		 */
		activity_id_or_spec?: Identifier,

		/**
		 *
		 */
		from_date?: number,

		/**
		 *
		 */
		to_date?: number

	): Promise<ResultEvent[]> {

		// Get the correctly scoped identifier to search within.
		let user_id: string | undefined
		let admin_id: number | undefined
		if (!!id && Identifier.unpack(id)[0] === (<any>Researcher).name)
			admin_id = Researcher._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id)[0] === (<any>Study).name)
			admin_id = Study._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id).length === 0 /* Participant */)
			user_id = Participant._unpack_id(id).study_id
		else if(!!id) throw new Error()

		user_id = !!user_id ? Encrypt(user_id) : user_id
		let conds = [
			!!user_id ? `Users.StudyId = '${user_id}'` : null,
			!!admin_id ? `Users.AdminID = '${admin_id}'` : null,
			!!from_date ? `DATEDIFF_BIG(MS, '1970-01-01', timestamp) >= ${from_date}` : null,
			!!to_date ? `DATEDIFF_BIG(MS, '1970-01-01', timestamp) <= ${to_date}` : null,
		].filter(x => !!x)
		let str = (conds.length > 0 ? ('WHERE ' + conds.join(' AND ')) : '')

		// Collect the set of legacy Activity tables and stitch the full query.
		let result = (await SQL!.request().query(`
			SELECT * FROM LAMP_Aux.dbo.ActivityIndex;
		`)).recordset.map(async (entry: any) => {

			// Perform the result lookup for every Activity table.
			let events = (await SQL!.request().query(`
				SELECT
					Users.StudyId AS uid,
	                [${entry.IndexColumnName}] AS id,
	                DATEDIFF_BIG(MS, '1970-01-01', [${entry.StartTimeColumnName}]) AS timestamp,
	                DATEDIFF_BIG(MS, [${entry.StartTimeColumnName}], [${entry.EndTimeColumnName}]) AS duration,
	                ${!entry.Slot1Name ?  '' :
	                    `[${entry.Slot1ColumnName}] AS [static_data.${entry.Slot1Name}],`}
	                ${!entry.Slot2Name ? '' :
	                    `[${entry.Slot2ColumnName}] AS [static_data.${entry.Slot2Name}],`}
	                ${!entry.Slot3Name ? '': 
	                    `[${entry.Slot3ColumnName}] AS [static_data.${entry.Slot3Name}],`}
	                ${!entry.Slot4Name ? '' :
	                    `[${entry.Slot4ColumnName}] AS [static_data.${entry.Slot4Name}],`}
	                ${!entry.Slot5Name ? '' : 
	                    `[${entry.Slot5ColumnName}] AS [static_data.${entry.Slot5Name}],`}
	                Users.AdminID AS aid
	            FROM [${entry.TableName}]
	            LEFT JOIN Users
	                ON [${entry.TableName}].UserID = Users.UserID
	            ${str.replace(/timestamp/g, `[${entry.StartTimeColumnName}]`)};
			`)).recordset

			if (events.length === 0)
				return []

			// If temporal events are recorded by the activity, look all of them up as well.
			let slices: any[] = []
			if (!!entry.TemporalTableName) {
				slices = (await SQL!.request().query(`
	                SELECT
	                    [${entry.TemporalTableName}].[${entry.IndexColumnName}] AS parent_id,
	                    ${!!entry.Temporal1ColumnName ? 
	                        `[${entry.TemporalTableName}].[${entry.Temporal1ColumnName}]` :
	                        '(NULL)'} AS item,
	                    ${!!entry.Temporal2ColumnName ?
	                        `[${entry.TemporalTableName}].[${entry.Temporal2ColumnName}]` :
	                        '(NULL)'} AS value,
	                    ${!!entry.Temporal3ColumnName ?
	                        `[${entry.TemporalTableName}].[${entry.Temporal3ColumnName}]` :
	                        '(NULL)'} AS type,
	                    ${!!entry.Temporal4ColumnName ?
	                        `CAST(CAST([${entry.TemporalTableName}].[${entry.Temporal4ColumnName}] AS float) * 1000 AS bigint)` :
	                        '(NULL)'} AS duration,
	                    ${!!entry.Temporal5ColumnName ?
	                        `[${entry.TemporalTableName}].[${entry.Temporal5ColumnName}]` :
	                        '(NULL)'} AS level
	                FROM [${entry.TemporalTableName}]
	                LEFT JOIN [${entry.TableName}]
	                    ON [${entry.TableName}].[${entry.IndexColumnName}] = [${entry.TemporalTableName}].[${entry.IndexColumnName}]
		            LEFT JOIN Users
		                ON [${entry.TableName}].UserID = Users.UserID
	                ${str};
				`)).recordset
			}

			// Map from SQL DB to the local ResultEvent type.
			let res = events.map(async (row: any) => {
				let result_event = new ResultEvent()
				result_event.timestamp = parseInt(row.timestamp)
				result_event.duration = parseInt(row.duration)
				;(<any>result_event).parent = !!admin_id ? Decrypt(row.uid) : undefined

				// Map internal ID sub-components into the single mangled ID form.
				result_event.activity = Activity._pack_id({ 
					activity_spec_id: entry.ActivityIndexID, 
					admin_id: row.aid, 
					survey_id: entry.ActivityIndexID !== '1' /* survey */ ? 0 : (row[`static_data.${entry.Slot2Name}`] || 0) 
				})

				// Copy static data fields if declared.
				result_event.static_data = {}
				if (!!entry.Slot1ColumnName)
					result_event.static_data[entry.Slot1Name] = row[`static_data.${entry.Slot1Name}`]
				if (!!entry.Slot2ColumnName)
					result_event.static_data[entry.Slot2Name] = row[`static_data.${entry.Slot2Name}`]
				if (!!entry.Slot3ColumnName)
					result_event.static_data[entry.Slot3Name] = row[`static_data.${entry.Slot3Name}`]
				if (!!entry.Slot4ColumnName)
					result_event.static_data[entry.Slot4Name] = row[`static_data.${entry.Slot4Name}`]
				if (!!entry.Slot5ColumnName)
					result_event.static_data[entry.Slot5Name] = row[`static_data.${entry.Slot5Name}`]

				// Decrypt all static data properties if known to be encrypted.
				// TODO: Encryption of fields should also be found in the ActivityIndex table!
				if (!!result_event.static_data.survey_name)
					result_event.static_data.survey_name = Decrypt(result_event.static_data.survey_name) || result_event.static_data.survey_name
				result_event.static_data.survey_id = undefined
				if (!!result_event.static_data.drawn_fig_file_name) {
					let fname = 'https://psych.digital/LampWeb/Games/User3DFigures/' + (Decrypt(result_event.static_data.drawn_fig_file_name) || result_event.static_data.drawn_fig_file_name)
					result_event.static_data.drawn_figure = fname//(await Download(fname)).toString('base64')
					result_event.static_data.drawn_fig_file_name = undefined
				}
                if (!!result_event.static_data.scratch_file_name) {
                    let fname = 'https://psych.digital/LampWeb/Games/UserScratchImages/' + (Decrypt(result_event.static_data.scratch_file_name) || result_event.static_data.scratch_file_name)
                    result_event.static_data.scratch_figure = fname//(await Download(fname)).toString('base64')
                    result_event.static_data.scratch_file_name = undefined
                }
				if (!!result_event.static_data.game_name)
					result_event.static_data.game_name = Decrypt(result_event.static_data.game_name) || result_event.static_data.game_name
				if (!!result_event.static_data.collected_stars)
					result_event.static_data.collected_stars = Decrypt(result_event.static_data.collected_stars) || result_event.static_data.collected_stars
				if (!!result_event.static_data.total_jewels_collected)
					result_event.static_data.total_jewels_collected = Decrypt(result_event.static_data.total_jewels_collected) || result_event.static_data.total_jewels_collected
				if (!!result_event.static_data.total_bonus_collected)
					result_event.static_data.total_bonus_collected = Decrypt(result_event.static_data.total_bonus_collected) || result_event.static_data.total_bonus_collected
				if (!!result_event.static_data.score)
					result_event.static_data.score = Decrypt(result_event.static_data.score) || result_event.static_data.score

				// Copy all temporal events for this result event by matching parent ID.
				if (!!slices) {
					result_event.temporal_events = slices
						.filter(slice_row => slice_row.parent_id === row.id)
						.map(slice_row => {
							let temporal_event = new TemporalEvent()
							temporal_event.item = slice_row.item
							temporal_event.value = slice_row.value
							temporal_event.type = slice_row.type
							temporal_event.duration = parseInt(slice_row.duration)
							temporal_event.level = slice_row.level

							// Special treatment for surveys with encrypted answers.
							if (entry.ActivityIndexID === '1' /* survey */) {
								temporal_event.item = Decrypt(temporal_event.item) || temporal_event.item
								temporal_event.value = Decrypt(temporal_event.value) || temporal_event.value
								temporal_event.type = !temporal_event.type ? undefined : (<string>temporal_event.type).toLowerCase()

								// Adjust the Likert scaled values to numbers.
								if (["Not at all", "12:00AM - 06:00AM", "0-3"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 0
								} else if (["Several Times", "06:00AM - 12:00PM", "3-6"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 1
								} else if (["More than Half the Time", "12:00PM - 06:00PM", "6-9"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 2
								} else if (["Nearly All the Time", "06:00PM - 12:00AM", ">9"].indexOf(temporal_event.value) >= 0) {
									temporal_event.value = 3
								}
							}
							return temporal_event
						})
				}

				// Finally return the newly created event.
				return result_event
			})
			return (<ResultEvent[]>[]).concat(...(await Promise.all(res)))
		})
		let all_res = (<ResultEvent[]>[]).concat(...(await Promise.all(result)))

		// Perform a group-by operation on the participant ID if needed.
		return !admin_id ? all_res : all_res.reduce((prev, curr: any) => {
			let key = (<any>curr).parent;
			(prev[key] ? prev[key] : (prev[key] = null || [])).push({ ...curr, parent: undefined })
			return prev
		}, (<any>{}))
	}

	/**
	 * Add a new `ResultEvent` with new fields.
	 */
	private static async _insert(

		/**
		 * The `StudyId` column of the `Users` table in the LAMP v0.1 DB.
		 */
		participant_id: Identifier,

		/**
		 * The new object to append.
		 */
		object: ResultEvent

	): Promise<{}> {
		let transaction = SQL!.transaction()
		await transaction.begin()

		try {
			let user_id = Encrypt(Participant._unpack_id(participant_id).study_id)
			let { activity_spec_id, admin_id, survey_id } = Activity._unpack_id(object.activity!)

			// Collect the set of legacy Activity tables and stitch the full query.
			let tableset = (await SQL!.request().query(`
				SELECT * FROM LAMP_Aux.dbo.ActivityIndex;
			`)).recordset
			let tablerow = tableset.filter((x: any) => parseInt(x['ActivityIndexID']) === activity_spec_id)[0]

			let userIDset = (await SQL!.request().query(`
				SELECT TOP 1 UserID FROM LAMP.dbo.Users WHERE StudyId = '${user_id}';
			`)).recordset

		    // First consume the timestamp + duration fields that are always present.
		    // FIXME: millisecond precision is lost!!
		    let columns: any = {}
		    let startTime = ((object.timestamp as number) || 0)
		    let endTime = ((object.timestamp as number) || 0) + (object.duration as number || 1)
		    columns[tablerow['StartTimeColumnName']] = `DATEADD(s, CONVERT(BIGINT, ${startTime}) / 1000, CONVERT(DATETIME, '1-1-1970 00:00:00'))`
		    columns[tablerow['EndTimeColumnName']] = `DATEADD(s, CONVERT(BIGINT, ${endTime}) / 1000, CONVERT(DATETIME, '1-1-1970 00:00:00'))`

		    // We only support 5 static slots; check if they're used by the activity first.
		    for (let x of [1, 2, 3, 4, 5]) {
		    	if (!!tablerow[`Slot${x}Name`]) {
		    		let value = object.static_data[tablerow[`Slot${x}Name`]]
		    		let isString = (typeof value === 'string' || value instanceof String)
		    		if (tablerow[`Slot${x}ColumnName`] === 'SurveyName') {
		    			value = Encrypt(value) // FIXME
						columns['SurveyType'] = 3 // FIXME 
						columns['SurveyID'] = survey_id // FIXME
		    		}

		    		columns[tablerow[`Slot${x}ColumnName`]] = isString ? `'${_escapeMSSQL(value)}'` : value
		    	}
		    }
		    
		    // Convert the static array into SQL strings.
		    let static_keys = Object.keys(columns).join(', ')
		    let static_values = Object.values(columns).join(', ')

		    // Insert row, returning the generated primary key ID.
		    let result: any = (await transaction.request().query(`
		    	INSERT INTO ${tablerow['TableName']} (
		    		UserID,
		    		Status,
	                ${static_keys}
	            )
	            OUTPUT INSERTED.${tablerow['IndexColumnName']} AS id
				VALUES (
					${userIDset[0]['UserID']},
					2,
			        ${static_values}
				);
		    `)).recordset

		    // Bail early if there was a failure to record the parent event row.
		    if (result.length === 0)
		    	throw new Error()
		    if (!tablerow['TemporalTableName'] || (object.temporal_events || []).length === 0) {
				await transaction.commit()
		    	return {}//result[0]
		    }

		    // Now the temporal fields are mapped for each sub-event.
		    let temporals = (object.temporal_events || []).map(event => [
		    	[tablerow['IndexColumnName'], result[0].id],
			    [tablerow['Temporal1ColumnName'], event.item || 'NULL'],
			    [tablerow['Temporal2ColumnName'], event.value || 'NULL'],
			    [tablerow['Temporal3ColumnName'], event.type || 'NULL'],
			    [tablerow['Temporal4ColumnName'], event.duration || '0'],
			    [tablerow['Temporal5ColumnName'], event.level || 'NULL'],
		    ].reduce((prev, curr) => {
		    	if (curr[0] === null) return prev;
		    	(<any>prev)[curr[0]] = curr[1]; return prev
		    }, {})).map((x: any) => {
				if (!!x['Question'])
					x['Question'] = `'${_escapeMSSQL(Encrypt(x['Question'])!)}'`
				if (!!x['CorrectAnswer'])
					x['CorrectAnswer'] = `'${_escapeMSSQL(Encrypt(x['CorrectAnswer'])!)}'`
				return x
		    })

		    // Convert the temporal arrays into SQL strings.
		    let temporal_keys = `(${Object.keys(temporals[0]).join(', ')})`
		    let temporal_values = temporals.map(x => `(${Object.values(x).join(', ')})`).join(', ')

		    // Insert sub-rows, without returning anything.
		    let result2 = (await transaction.request().query(`
		    	INSERT INTO ${tablerow['TemporalTableName']} ${temporal_keys}
				VALUES ${temporal_values};
		    `))

		    // Bail early if there was a failure to record the parent event row.
		    if (result2.rowsAffected[0] === 0)
		    	throw new Error()

		    // Return the new parent row's ID.
			await transaction.commit()
		    return {}//!!result2 ? result : null;
		} catch(e) {
			await transaction.rollback()
			throw e
		}
	}

	/**
	 * Deletes a `ResultEvent` row.
	 */
	private static async _delete(

		/**
		 * The `StudyId` column of the `Users` table in the LAMP v0.1 DB.
		 */
		participant_id: Identifier,

		/**
		 * 
		 */
		activity_id_or_spec?: Identifier,

		/**
		 *
		 */
		from_date?: number,

		/**
		 *
		 */
		to_date?: number

	): Promise<{}> {
		throw new Unimplemented()

		/*
		let user_id = Encrypt(Participant._unpack_id(participant_id).study_id)

		// Collect the set of legacy Activity tables and stitch the full query.
		let tableset = (await SQL!.request().query(`
			SELECT * FROM LAMP_Aux.dbo.ActivityIndex;
		`)).recordset;

		// TODO: Deletion is not supported! CreatedOn is not correctly used here.
		(await SQL!.request().query(`
			UPDATE ${tablerow['TableName']} SET CreatedOn = NULL WHERE ${tablerow['IndexColumnName']} = ${type_id};
		`)).recordset;
		*/
		return {}
	}
}

const _escapeMSSQL = (val: string) => val.replace(/[\0\n\r\b\t\\'"\x1a]/g, (s: string) => {
	switch (s) {
	  case "\0":
	    return "\\0";
	  case "\n":
	    return "\\n";
	  case "\r":
	    return "\\r";
	  case "\b":
	    return "\\b";
	  case "\t":
	    return "\\t";
	  case "\x1a":
	    return "\\Z";
	  case "'":
	    return "''";
	  case '"':
	    return '""';
	  default:
	    return "\\" + s;
	}
})
