import { SQL, Encrypt, Decrypt } from '../index'
import { 
	d, Schema, Property, Description, Retype, Route, Throws, 
	Path, BadRequest, NotFound, AuthorizationFailed, Auth,
	Enum, Ownership, Identifier, Parent, Body, Double, Timestamp
} from '../utils/OpenAPI'
import { IResult } from 'mssql'

import { Participant } from './Participant'
import { Study } from './Study'
import { Researcher } from './Researcher'

export enum LocationContext {
	Home = 'home',
	School = 'school',
	Work = 'work',
	Hospital = 'hospital',
	Outside = 'outside',
	Shopping = 'shopping',
	Transit = 'transit'
}
Enum(LocationContext, d`
	The location-specific context for the environment.
`)

export enum SocialContext {
	Alone = 'alone',
	Friends = 'friends',
	Family = 'family',
	Peers = 'peers',
	Crowd = 'crowd',
}
Enum(SocialContext, d`
	The social-specific context for the environment.
`)

@Schema()
@Parent(Participant)
@Description(d`
	An event generated by the participant's location 
	and if self-reported, the associated context.
`)
export class EnvironmentEvent {

	@Property()
	@Description(d`
		The self-referencing identifier to this object.
	`)
	public id?: Identifier

	@Property()
	@Description(d`
		External or out-of-line objects attached to this object.
	`)
	public attachments?: any

	@Property()
	@Description(d`
		The date and time when this event was recorded.
	`)
	public timestamp?: Timestamp

	@Property()
	@Description(d`
		The GPS coordinates or approximate postal address recorded with the event.
	`)
	public coordinates?: Double[]

	@Property()
	@Description(d`
		The accuracy of provided GPS coordinates; if \`null\`, 
		the coordinates represent an approximate postal address.
	`)
	public accuracy?: Double

	@Property()
	@Description(d`
		The location context self-reported by the participant with the event.
	`)
	public location_context?: LocationContext

	@Property()
	@Description(d`
		The social context self-reported by the participant with the event.
	`)
	public social_context?: SocialContext

	@Route.POST('/participant/{participant_id}/environment_event') 
	@Description(d`
		Create a new EnvironmentEvent for the given Participant.
	`)
	@Auth(Ownership.Self, 'participant_id')
	@Retype(Identifier, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async create(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string,

		@Body()
		environment_event: EnvironmentEvent,

	): Promise<Identifier> {
		return EnvironmentEvent._insert(participant_id, environment_event)
	}

	@Route.PUT('/environment_event/{environment_event_id}') 
	@Description(d`
		Update an environment event.
	`)
	@Auth(Ownership.Self, 'environment_event_id')
	@Retype(Identifier, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async update(

		@Path('environment_event_id')
		@Retype(Identifier, EnvironmentEvent)
		environment_event_id: string,

		@Body()
		environment_event: EnvironmentEvent,

	): Promise<Identifier> {
		return EnvironmentEvent._update(environment_event_id, environment_event)
	}

	@Route.DELETE('/environment_event/{environment_event_id}') 
	@Description(d`
		Delete an environment event.
	`)
	@Auth(Ownership.Self, 'environment_event_id')
	@Retype(Identifier, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async delete(

		@Path('environment_event_id')
		@Retype(Identifier, EnvironmentEvent)
		environment_event_id: string

	): Promise<Identifier> {
		return EnvironmentEvent._delete(environment_event_id)
	}

	@Route.GET('/environment_event/{environment_event_id}') 
	@Description(d`
		Get a single environment event, by identifier.
	`)
	@Auth(Ownership.Self, 'environment_event_id')
	@Retype(Array, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async view(

		@Path('environment_event_id')
		@Retype(Identifier, EnvironmentEvent)
		environment_event_id: string

	): Promise<EnvironmentEvent[]> {
		return EnvironmentEvent._select(environment_event_id)
	}

	@Route.GET('/participant/{participant_id}/environment_event') 
	@Description(d`
		Get the set of all environment events for a single participant.
	`)
	@Auth(Ownership.Parent, 'participant_id')
	@Retype(Array, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_participant(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string

	): Promise<EnvironmentEvent[]> {
		return EnvironmentEvent._select(participant_id)
	}

	@Route.GET('/study/{study_id}/environment_event') 
	@Description(d`
		Get the set of all environment events produced by participants 
		participants of a single study, by study identifier.
	`)
	@Auth(Ownership.Parent, 'study_id')
	@Retype(Array, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_study(

		@Path('study_id')
		@Retype(Identifier, Study)
		study_id: string

	): Promise<EnvironmentEvent[]> {
		return EnvironmentEvent._select(study_id)
	}

	@Route.GET('/researcher/{researcher_id}/environment_event') 
	@Description(d`
		Get the set of all activities available to participants 
		of any study conducted by a researcher, by researcher identifier.
	`)
	@Auth(Ownership.Parent, 'researcher_id')
	@Retype(Array, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_researcher(

		@Path('researcher_id')
		@Retype(Identifier, Researcher)
		researcher_id: string

	): Promise<EnvironmentEvent[]> {
		return EnvironmentEvent._select(researcher_id)
	}

	@Route.GET('/environment_event') 
	@Description(d`
		Get the set of all environmental events for any participant.
	`)
	@Auth(Ownership.Root)
	@Retype(Array, EnvironmentEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all(

	): Promise<EnvironmentEvent[]> {
		return EnvironmentEvent._select()
	}

	/**
	 *
	 */
	public static _pack_id(components: {

		/**
		 * 
		 */
		event_id?: number

	}): Identifier {
		return Identifier.pack([
			(<any>EnvironmentEvent).name, 
			components.event_id || 0,
		])
	}

	/**
	 *
	 */
	public static _unpack_id(id: Identifier): ({

		/**
		 * 
		 */
		event_id: number

	}) {
		let components = Identifier.unpack(id)
		if (components[0] !== (<any>EnvironmentEvent).name)
			throw new Error('invalid identifier')
		let result = components.slice(1).map(parseInt)
		return {
			event_id: !isNaN(result[0]) ? result[0] : 0
		}
	}

	/**
	 *
	 */
	public static async _parent_id(id: Identifier, type: Function): Promise<Identifier | undefined> {
		let { event_id } = EnvironmentEvent._unpack_id(id)
		switch (type) {
			case Participant: 
				let result = (await SQL!.request().query(`
                    SELECT StudyId AS value
                    FROM Locations
                    LEFT JOIN Users
                        ON Users.UserID = Locations.UserID
                    WHERE LocationID = '${event_id}';
				`)).recordset
				return result.length === 0 ? undefined : 
					Participant._pack_id({ study_id: result[0].value })

			case Study:
			case Researcher: 
				let result2 = (await SQL!.request().query(`
                    SELECT AdminID AS value
                    FROM Locations
                    LEFT JOIN Users
                        ON Users.UserID = Locations.UserID
                    WHERE LocationID = '${event_id}';
				`)).recordset
				return result2.length === 0 ? undefined : 
					(type === Researcher ? Researcher : Study)._pack_id({ admin_id: result2[0].value })

			default: throw new Error()
		}
	}

	/**
	 * Get a set of `EnvironmentEvent`s matching the criteria parameters.
	 */
	private static async _select(

		/**
		 * 
		 */
		id?: Identifier

	): Promise<EnvironmentEvent[]> {

		// Get the correctly scoped identifier to search within.
		let user_id: string | undefined
		let admin_id: number | undefined
		let location_id: number | undefined
		if (!!id && Identifier.unpack(id)[0] === (<any>Researcher).name)
			admin_id = Researcher._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id)[0] === (<any>Study).name)
			admin_id = Study._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id).length === 0 /* Participant */)
			user_id = Participant._unpack_id(id).study_id
		else if (!!id && Identifier.unpack(id)[0] === (<any>EnvironmentEvent).name)
			location_id = EnvironmentEvent._unpack_id(id).event_id
		else if(!!id) throw new Error()

		user_id = !!user_id ? Encrypt(user_id) : undefined
		let result = await SQL!.request().query(`
			SELECT 
                LocationID AS id, 
                (NULL) AS attachments, 
                DATEDIFF_BIG(MS, '1970-01-01', Locations.CreatedOn) AS [timestamp],
                (CASE 
                    WHEN Coordinates IS NOT NULL THEN Coordinates
                    ELSE Locations.Address
                END) AS coordinates,
                (CASE 
                    WHEN Coordinates IS NULL THEN NULL
                    ELSE 1
                END) AS accuracy,
                (NULL) AS location_context,
                (NULL) AS social_context,
                Type AS type,
                LocationName AS location_name 
            FROM Locations
            LEFT JOIN Users
                ON Locations.UserID = Users.UserID
            LEFT JOIN LAMP_Aux.dbo.GPSLookup 
                ON Locations.Address = LAMP_Aux.dbo.GPSLookup.Address
            WHERE IsDeleted = 0 
                ${!!location_id ? `AND LocationID = '${location_id}'` : ''}
                ${!!user_id ? `AND Users.StudyId = '${user_id}'` : ''}
                ${!!admin_id ? `AND Users.AdminID = '${admin_id}'` : ''}
            FOR JSON PATH, INCLUDE_NULL_VALUES;
		`)

		if (result.recordset.length === 0)
			return []

        // Map from SQL DB to the local EnvironmentEvent type.
		return result.recordset[0].map((raw: any) => {
			let obj = new EnvironmentEvent()
			obj.id = EnvironmentEvent._pack_id({ event_id: raw.id })
			obj.timestamp = raw.timestamp
			obj.coordinates = (Decrypt(raw.coordinates) || raw.coordinates).split(',').map(parseFloat)
			obj.accuracy = raw.accuracy

			let x = toLAMP(raw.location_name)
			obj.location_context = x[0] 
			obj.social_context = x[1]
			return obj
		})
	}

	/**
	 * Add a new `EnvironmentEvent` with new fields.
	 */
	private static async _insert(

		/**
		 * The `StudyId` column of the `Users` table in the LAMP v0.1 DB.
		 */
		participant_id: Identifier,

		/**
		 * The new object to append.
		 */
		object: EnvironmentEvent

	): Promise<Identifier> {

		let user_id = Participant._unpack_id(participant_id).study_id

	    // Prepare the minimal SQL column changes from the provided fields.
	    // If a location or social context is provided, map them back to the original strings.
		let loc_name = fromLAMP([object.location_context, object.social_context])
		user_id = Encrypt(user_id) || user_id
		let lat = Encrypt('' + object.coordinates![0]) || ('' + object.coordinates![0])
		let long = Encrypt('' + object.coordinates![1]) || ('' + object.coordinates![1])
		let type = (!!object.location_context || !!object.social_context) ? 2 : 1

	    // Insert row, returning the generated primary key ID. Return the new row's ID.
		return (await SQL!.request().query(`
			INSERT INTO Locations (
                UserID,
                LocationName, 
                CreatedOn, 
                Type, 
                Latitude, 
                Longitude
            )
            OUTPUT INSERTED.LocationID AS id
			VALUES (
		        '${user_id}',
		        '${loc_name}',
		        DATEADD(MS, ${object.timestamp}, '1970-01-01'), 
		        ${type},
		        '${lat}',
		        '${long}'
			);
		`)).recordset[0]
	}

	/**
	 * Update an `EnvironmentEvent` with new fields.
	 */
	private static async _update(

		/**
		 * The `LocationID` column of the `Locations` table in the LAMP v0.1 DB.
		 */
		event_id: Identifier,

		/**
		 * The replacement object or specific fields within.
		 */
		object: EnvironmentEvent

	): Promise<Identifier> {

		let location_id = EnvironmentEvent._unpack_id(event_id).event_id

		// Prepare the minimal SQL column changes from the provided fields.
		// If a location or social context is provided, map them back to the original strings.
		// TODO: Cannot update EITHER location OR social, must update BOTH together!
		let loc_name = fromLAMP([object.location_context, object.social_context])
		let updates: string[] = []
		if (!!loc_name)
			updates.push(`LocationName = '${loc_name}'`)
		updates.push(
			`Type = ${!!loc_name ? 2 : 1}`,
			`Latitude = '${Encrypt('' + object.coordinates![0])}'`,
			`Longitude = '${Encrypt('' + object.coordinates![1])}'`
		)

		if (updates.length == 0)
			throw new Error()

		// Insert row, returning the generated primary key ID. Return whether the operation was successful.
		return (await SQL!.request().query(`
			UPDATE Locations SET ${updates.join(', ')} WHERE LocationID = ${location_id}; 
		`)).recordset[0]
	}

	/**
	 * Deletes an `EnvironmentEvent` row.
	 */
	private static async _delete(

		/**
		 * The `LocationID` column of the `Locations` table in the LAMP v0.1 DB.
		 */
		event_id: Identifier

	): Promise<Identifier> {

		let location_id = EnvironmentEvent._unpack_id(event_id).event_id

		// Set the deletion flag, without actually deleting the row.
		// TODO: Deletion is not supported! Type is not correctly used here.
		return (await SQL!.request().query(`
			UPDATE Locations SET Type = 0 WHERE LocationID = ${location_id};
		`)).recordset[0]
	}
}

/**
 *
 */
const toLAMP = (value?: string): [LocationContext?, SocialContext?] => {
	if (!value) return []
	let matches = (Decrypt(value) || value).toLowerCase()
					.match(/(?:i am )([ \S\/]+)(alone|in [ \S\/]*|with [ \S\/]*)/) || []
	return [
		(<any>{
			'home': LocationContext.Home,
			'in school/class': LocationContext.School,
			'at work': LocationContext.Work,
			'in clinic/hospital': LocationContext.Hospital,
			'outside': LocationContext.Outside,
			'shopping/dining': LocationContext.Shopping,
			'in bus/train/car': LocationContext.Transit,
		})[(matches[1] || ' ').slice(0, -1)],
		(<any>{
			'alone': SocialContext.Alone,
			'with friends': SocialContext.Friends,
			'with family': SocialContext.Family,
			'with peers': SocialContext.Peers,
			'in crowd': SocialContext.Crowd,
		})[(matches[2] || '')]
	]
}

/**
 *
 */
const fromLAMP = (value: [LocationContext?, SocialContext?]): string | undefined => {
	if (!value[0] && !value[1]) return undefined
	return Encrypt('i am' + (<any>{
		'home': ' home',
		'school': ' in school/class',
		'work': ' at work',
		'hospital': ' in clinic/hospital',
		'outside': ' outside',
		'shopping': ' shopping/dining',
		'transit': ' in bus/train/car',
	})[(value[0] || '')] + (<any>{
		'alone': 'alone',
		'friends': 'with friends',
		'family': 'with family',
		'peers': 'with peers',
		'crowd': 'in crowd',
	})[(value[1] || '')])
}
