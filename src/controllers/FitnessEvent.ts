import { SQL, Encrypt, Decrypt } from '../index'
import { 
	d, Schema, Property, Description, Retype, Route, Throws, 
	Path, BadRequest, NotFound, AuthorizationFailed, Auth,
	Enum, Ownership, Identifier, Parent, Body, Double, Timestamp
} from '../utils/OpenAPI'
import { IResult } from 'mssql'

import { Participant } from './Participant'
import { Study } from './Study'
import { Researcher } from './Researcher'

export enum FitnessSampleType {
	Height = 'height',
	Weight = 'weight',
	HeartRate = 'heart_rate',
	BloodPressure = 'blood_pressure',
	RespiratoryRate = 'respiratory_rate',
	Sleep = 'sleep',
	Steps = 'steps',
	Flights = 'flights',
	Segment = 'segment',
	Distance = 'distance'
}
Enum(FitnessSampleType, d`
	The kind of fitness event produced.
`)

@Schema()
@Description(d`
	A fitness sub-sample within an event.
`)
export class FitnessSample {

	@Property()
	@Description(d`
		The type of fitness sample.
	`)
	public type?: FitnessSampleType

	@Property()
	@Description(d`
		The units used in the value of the sample.
	`)
	public unit?: string

	@Property()
	@Description(d`
		The numeric or string value of the sample.
	`)
	public value?: any
}

@Schema()
@Parent(Participant)
@Description(d`
	An event generated by a participant's device, linked 
	fitness trackers, or wearable devices.
`)
export class FitnessEvent {

	@Property()
	@Description(d`
		The self-referencing identifier to this object.
	`)
	public id?: Identifier

	@Property()
	@Description(d`
		External or out-of-line objects attached to this object.
	`)
	public attachments?: any

	@Property()
	@Description(d`
		The date and time when this event was recorded.
	`)
	public timestamp?: Timestamp

	@Property()
	@Retype(Array, FitnessSample)
	@Description(d`
		The set of all sub-samples within the event.
	`)
	public record?: FitnessSample[]

	@Route.POST('/participant/{participant_id}/fitness_event') 
	@Description(d`
		Create a new FitnessEvent for the given Participant.
	`)
	@Auth(Ownership.Self, 'participant_id')
	@Retype(Identifier, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async create(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string,

		@Body()
		fitness_event: FitnessEvent,

	): Promise<Identifier> {
		return FitnessEvent._insert(participant_id, fitness_event)
	}

	@Route.PUT('/fitness_event/{fitness_event_id}') 
	@Description(d`
		Update the FitnessEvent.
	`)
	@Auth(Ownership.Self, 'fitness_event_id')
	@Retype(Identifier, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async update(

		@Path('fitness_event_id')
		@Retype(Identifier, FitnessEvent)
		fitness_event_id: string,

		@Body()
		fitness_event: FitnessEvent,

	): Promise<Identifier> {
		return FitnessEvent._update(fitness_event_id, fitness_event)
	}

	@Route.DELETE('/fitness_event/{fitness_event_id}') 
	@Description(d`
		Delete a fitness event.
	`)
	@Auth(Ownership.Self, 'fitness_event_id')
	@Retype(Identifier, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async delete(

		@Path('fitness_event_id')
		@Retype(Identifier, FitnessEvent)
		fitness_event_id: string

	): Promise<Identifier> {
		return FitnessEvent._delete(fitness_event_id)
	}

	@Route.GET('/fitness_event/{fitness_event_id}') 
	@Description(d`
		Get a single fitness event, by identifier.
	`)
	@Auth(Ownership.Self, 'fitness_event_id')
	@Retype(Array, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async view(

		@Path('fitness_event_id')
		@Retype(Identifier, FitnessEvent)
		fitness_event_id: string

	): Promise<FitnessEvent[]> {
		return FitnessEvent._select(fitness_event_id)
	}

	@Route.GET('/participant/{participant_id}/fitness_event') 
	@Description(d`
		Get the set of all fitness events produced by a single participant.
	`)
	@Auth(Ownership.Parent, 'participant_id')
	@Retype(Array, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_participant(

		@Path('participant_id')
		@Retype(Identifier, Participant)
		participant_id: string

	): Promise<FitnessEvent[]> {
		return FitnessEvent._select(participant_id)
	}

	@Route.GET('/study/{study_id}/fitness_event') 
	@Description(d`
		Get the set of all fitness events produced by participants 
		participants of a single study, by study identifier.
	`)
	@Auth(Ownership.Parent, 'study_id')
	@Retype(Array, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_study(

		@Path('study_id')
		@Retype(Identifier, Study)
		study_id: string

	): Promise<FitnessEvent[]> {
		return FitnessEvent._select(study_id)
	}

	@Route.GET('/researcher/{researcher_id}/fitness_event') 
	@Description(d`
		Get the set of all fitness events produced by participants 
		of any study conducted by a researcher, by researcher identifier.
	`)
	@Auth(Ownership.Parent, 'researcher_id')
	@Retype(Array, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all_by_researcher(

		@Path('researcher_id')
		@Retype(Identifier, Researcher)
		researcher_id: string

	): Promise<FitnessEvent[]> {
		return FitnessEvent._select(researcher_id)
	}

	@Route.GET('/fitness_event') 
	@Description(d`
		Get the set of all fitness events for any participant.
	`)
	@Auth(Ownership.Root)
	@Retype(Array, FitnessEvent)
	@Throws(BadRequest, AuthorizationFailed, NotFound)
	public static async all(

	): Promise<FitnessEvent[]> {
		return FitnessEvent._select()
	}

	/**
	 *
	 */
	public static _pack_id(components: {

		/**
		 * 
		 */
		event_id?: number

	}): Identifier {
		return Identifier.pack([
			(<any>FitnessEvent).name, 
			components.event_id || 0,
		])
	}

	/**
	 *
	 */
	public static _unpack_id(id: Identifier): ({

		/**
		 * 
		 */
		event_id: number

	}) {
		let components = Identifier.unpack(id)
		if (components[0] !== (<any>FitnessEvent).name)
			throw new Error('invalid identifier')
		let result = components.slice(1).map(parseInt)
		return {
			event_id: !isNaN(result[0]) ? result[0] : 0
		}
	}

	/**
	 *
	 */
	public static async _parent_id(id: Identifier, type: Function): Promise<Identifier | undefined> {
		let { event_id } = FitnessEvent._unpack_id(id)
		switch (type) {
			case Participant: 
				let result = (await SQL!.request().query(`
                    SELECT StudyId AS value
                    FROM HealthKit_DailyValues
                    LEFT JOIN Users
                        ON Users.UserID = HealthKit_DailyValues.UserID
                    WHERE HKDailyValueID = '${event_id}';
				`)).recordset
				return result.length === 0 ? undefined : 
					Participant._pack_id({ study_id: result[0].value })

			case Study:
			case Researcher: 
				let result2 = (await SQL!.request().query(`
                    SELECT AdminID AS value
                    FROM HealthKit_DailyValues
                    LEFT JOIN Users
                        ON Users.UserID = HealthKit_DailyValues.UserID
                    WHERE HKDailyValueID = '${event_id}';
				`)).recordset
				return result2.length === 0 ? undefined : 
					(type === Researcher ? Researcher : Study)._pack_id({ admin_id: result2[0].value })

			default: throw new Error()
		}
	}

	/**
	 * Get a set of `FitnessEvent`s matching the criteria parameters.
	 */
	private static async _select(

		/**
		 * 
		 */
		id?: Identifier

	): Promise<FitnessEvent[]> {

		// Get the correctly scoped identifier to search within.
		let user_id: string | undefined
		let admin_id: number | undefined
		let health_id: number | undefined
		if (!!id && Identifier.unpack(id)[0] === (<any>Researcher).name)
			admin_id = Researcher._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id)[0] === (<any>Study).name)
			admin_id = Study._unpack_id(id).admin_id
		else if (!!id && Identifier.unpack(id).length === 0 /* Participant */)
			user_id = Participant._unpack_id(id).study_id
		else if (!!id && Identifier.unpack(id)[0] === (<any>FitnessEvent).name)
			health_id = FitnessEvent._unpack_id(id).event_id
		else if(!!id) throw new Error()

		user_id = !!user_id ? Encrypt(user_id) : user_id		
		let result = await SQL!.request().query(`
			SELECT 
                HKDailyValueID AS id, 
                (0) AS attachments, 
                DATEDIFF_BIG(MS, '1970-01-01', HealthKit_DailyValues.CreatedOn) AS [timestamp],
                (CASE 
                    WHEN LEN(Height) > 0 THEN Height ELSE NULL 
                END) AS [record.height], 
                (CASE 
                    WHEN LEN(Weight) > 0 THEN Weight ELSE NULL
                END) AS [record.weight], 
                (CASE 
                    WHEN LEN(HeartRate) > 0 THEN HeartRate ELSE NULL 
                END) AS [record.heart_rate], 
                (CASE 
                    WHEN LEN(BloodPressure) > 0 THEN BloodPressure ELSE NULL 
                END) AS [record.blood_pressure], 
                (CASE 
                    WHEN LEN(RespiratoryRate) > 0 THEN RespiratoryRate ELSE NULL 
                END) AS [record.respiratory_rate], 
                (CASE 
                    WHEN LEN(Sleep) > 0 THEN Sleep ELSE NULL 
                END) AS [record.sleep], 
                (CASE 
                    WHEN LEN(Steps) > 0 THEN Steps ELSE NULL 
                END) AS [record.steps], 
                (CASE 
                    WHEN LEN(FlightClimbed) > 0 THEN FlightClimbed ELSE NULL 
                END) AS [record.flights], 
                (CASE 
                    WHEN LEN(Segment) > 0 THEN Segment ELSE NULL 
                END) AS [record.segment], 
                (CASE 
                    WHEN LEN(Distance) > 0 THEN Distance ELSE NULL 
                END) AS [record.distance]
            FROM HealthKit_DailyValues
            LEFT JOIN Users
                ON HealthKit_DailyValues.UserID = Users.UserID
            WHERE IsDeleted = 0 
                ${!!health_id ? `AND HKDailyValueID = '${health_id}'` : ''} 
                ${!!user_id ? `AND Users.StudyId = '${user_id}'` : ''} 
                ${!!admin_id ? `AND Users.AdminID = '${admin_id}'` : ''}
            FOR JSON PATH;
		`)

		if (result.recordset.length === 0)
			return []

		// Helper functions to clean up the strings into values.
		const _decrypt = function(str: string) {
			let v = Decrypt(str) 
			return (!v || v === '' || v === 'NA') ? undefined : v.toLowerCase()
		}
		const _convert = function(x?: string, strip_suffix: string = '', convert_number: boolean = false) {
			return !x ? undefined : (convert_number ? parseFloat(x.replace(strip_suffix, '')) : x.replace(strip_suffix, ''))
		}
		const _clean = function(x: any) {
			return x === 0 ? undefined : x
		}
		const _make_sample = function(key: FitnessSampleType, value: any) {
			let y = new FitnessSample()
			y.type = key
			y.value = value
			return y
		}

        // Map from SQL DB to the local FitnessEvent type.
        return result.recordset[0].map((raw: any) => {
        	let obj = new FitnessEvent()
        	obj.id = FitnessEvent._pack_id({ event_id: raw.id })
        	obj.record = []

        	if (!!raw.record.height)
        		obj.record.push(_make_sample(FitnessSampleType.Height, 
        			_convert(_decrypt(raw.record.height), ' cm', true)))
        	if (!!raw.record.weight)
        		obj.record.push(_make_sample(FitnessSampleType.Weight, 
        			_convert(_decrypt(raw.record.weight), ' kg', true)))
        	if (!!raw.record.heart_rate)
        		obj.record.push(_make_sample(FitnessSampleType.HeartRate, 
        			_convert(_decrypt(raw.record.heart_rate), ' bpm', true)))
        	if (!!raw.record.blood_pressure)
        		obj.record.push(_make_sample(FitnessSampleType.BloodPressure, 
        			_convert(_decrypt(raw.record.blood_pressure), ' mmhg', false)))
        	if (!!raw.record.respiratory_rate)
        		obj.record.push(_make_sample(FitnessSampleType.RespiratoryRate, 
        			_convert(_decrypt(raw.record.respiratory_rate), ' breaths/min', true)))
        	if (!!raw.record.sleep)
        		obj.record.push(_make_sample(FitnessSampleType.Sleep, 
        			_decrypt(raw.record.sleep)))
        	if (!!raw.record.steps)
        		obj.record.push(_make_sample(FitnessSampleType.Steps, 
        			_clean(_convert(_decrypt(raw.record.steps), ' steps', true))))
        	if (!!raw.record.flights)
        		obj.record.push(_make_sample(FitnessSampleType.Flights, 
        			_clean(_convert(_decrypt(raw.record.flights), ' steps', true))))
        	if (!!raw.record.segment)
        		obj.record.push(_make_sample(FitnessSampleType.Segment, 
        			_convert(_decrypt(raw.record.segment), '', true)))
        	if (!!raw.record.distance)
        		obj.record.push(_make_sample(FitnessSampleType.Distance, 
        			_convert(_decrypt(raw.record.distance), ' meters', true)))

        	return obj
        })
	}

	/**
	 * Add a new `FitnessEvent` with new fields.
	 */
	private static async _insert(

		/**
		 * The `StudyId` column of the `Users` table in the LAMP v0.1 DB.
		 */
		participant_id: Identifier,

		/**
		 * The new object to append.
		 */
		object: FitnessEvent

	): Promise<Identifier> {

		let user_id = Participant._unpack_id(participant_id).study_id

		// Append these specific units to each entry.
		const unit_map = {
			height: ' cm',
			weight: ' kg',
			heart_rate: ' bpm',
			blood_pressure: ' mmhg',
			respiratory_rate: ' breaths/min',
			sleep: '',
			steps: ' steps',
			flights: ' steps',
			segment: '',
			distance: ' meters'
		}

    	// Convert samples to a suffixed and encrypted dictionary.
    	let columns: any = {}
    	for (let rec of (object.record || []))
    		columns[rec.type!] = Encrypt(rec.value! + '' + unit_map[rec.type!])

	    // Insert row, returning the generated primary key ID. Return the new row's ID.
	    return (await SQL!.request().query(`
	    	INSERT INTO HealthKit_DailyValues (
                UserID,
                Height, 
                Weight, 
                HeartRate, 
                BloodPressure, 
                RespiratoryRate,
                Sleep, 
                Steps, 
                FlightClimbed,
                CreatedOn, 
                Segment, 
                Distance
            )
            OUTPUT INSERTED.HKDailyValueID AS id
			VALUES (
		        '${user_id}',
		        '${columns.height || 'NULL'}',
		        '${columns.weight || 'NULL'}',
		        '${columns.heart_rate || 'NULL'}',
		        '${columns.blood_pressure || 'NULL'}',
		        '${columns.respiratory_rate || 'NULL'}',
		        '${columns.sleep || 'NULL'}',
		        '${columns.steps || 'NULL'}',
		        '${columns.flights || 'NULL'}',
		        DATEADD(MS, ${object.timestamp}, '1970-01-01'), 
		        '${columns.segment || 'NULL'}',
		        '${columns.distance || 'NULL'}'
			);
	    `)).recordset[0]
	}

	/**
	 * Update a `FitnessEvent` with new fields.
	 */
	private static async _update(

		/**
		 * The `HKDailyValueID` column of the `HKDailyValues` table in the LAMP v0.1 DB.
		 */
		event_id: Identifier,

		/**
		 * The replacement object or specific fields within.
		 */
		object: FitnessEvent

	): Promise<Identifier> {

		let daily_value_id = FitnessEvent._unpack_id(event_id).event_id

		// Map between FitnessSampleType to HKDailyValues columns.
		const record_map = {
			height: 'Height',
			weight: 'Weight',
			heart_rate: 'HeartRate',
			blood_pressure: 'BloodPressure',
			respiratory_rate: 'RespiratoryRate',
			sleep: 'Sleep',
			steps: 'Steps',
			flights: 'FlightClimbed',
			segment: 'Segment',
			distance: 'Distance'
		}

		// Append these specific units to each entry.
		const unit_map = {
			height: ' cm',
			weight: ' kg',
			heart_rate: ' bpm',
			blood_pressure: ' mmhg',
			respiratory_rate: ' breaths/min',
			sleep: '',
			steps: ' steps',
			flights: ' steps',
			segment: '',
			distance: ' meters'
		}

		// Prepare the minimal SQL column changes from the provided fields.
		// Convert samples to a suffixed and encrypted dictionary.
		let updates = []
		for (let rec of (object.record || []))
			updates.push(`${record_map[rec.type!]} = ${Encrypt(rec.value! + '' + unit_map[rec.type!])}`)
		if (!!object.timestamp)
			updates.push(`CreatedOn = DATEADD(MS, ${object.timestamp}, \'1970-01-01\')`)
		
		if (updates.length === 0)
			throw new Error()

		// Insert row, returning the generated primary key ID. Return whether the operation was successful.
		return (await SQL!.request().query(`
			UPDATE HealthKit_DailyValues SET ${updates.join(', ')} WHERE HKDailyValueID = ${daily_value_id}; 
		`)).recordset[0]
	}

	/**
	 * Deletes a `FitnessEvent` row.
	 */
	private static async _delete(

		/**
		 * The `HKDailyValueID` column of the `HKDailyValues` table in the LAMP v0.1 DB.
		 */
		event_id: Identifier

	): Promise<Identifier> {

		let daily_value_id = FitnessEvent._unpack_id(event_id).event_id

		// Set the deletion flag, without actually deleting the row. Return whether the operation was successful.
		// TODO: Deletion is not supported! EditedOn is not correctly used here.
		return (await SQL!.request().query(`
			UPDATE HealthKit_DailyValues SET EditedOn = NULL WHERE HKDailyValueID = ${daily_value_id};
		`)).recordset[0]
	}
}
